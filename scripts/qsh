#!/bin/bash

QSH_BASE="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# Store some basic information about our execution environment
QSH=$BASH_SOURCE
QSH_PAGER_COMMAND="$QSH_BASE/qsh-pager"
PANE_ID=$(tmux display-message -p '#{pane_id}')
PID=$$

# Base directory for query editor tmp files
QSH_TMP=/tmp/qsh

# The client pane file, which hosts the SQL client session, and the editor pane file, which is
# running the editor, e.g. vim. Each file will store data related to the opposite pane, so that
# when that pane executes this script it can easily access the information for it's related pane
CLIENT_PANE=$QSH_TMP/client.${PANE_ID}
EDITOR_PANE=$QSH_TMP/editor.${PANE_ID}

# The query file that will be used to transport the single query batch to be executed to the
# SQL client
QSH_EXECUTE_QUERY=${QSH_EXECUTE_QUERY:-$QSH_TMP/execute.${PANE_ID}.sql}

# When invoked from the SQL client, this will contain the file it expects to contain the query
# to execute. The script can, however, also be involved by the editor, in which case this
# script parameter will be empty
OUTPUT_FILE=$1

# Query editor options & default values
QSH_EDITOR_COMMAND=${QSH_EDITOR_COMMAND:-'\e\;'}
QSH_SWITCH_ON_EXECUTE=${QSH_SWITCH_ON_EXECUTE:-0}
QSH_EXECUTE_DELAY=${QSH_EXECUTE_DELAY:-0.1}

# The editor to use
QSH_EDITOR=${QSH_EDITOR:-$VISUAL}

# Other variable(s)
QSH_INIT_FILE=".init.sh"

# Guarantees that the output file will register as changed
function touch_output {
  case $OSTYPE in
    linux*)
      TS=$(date -d '+1 second' +"%Y%m%d%H%M.%S")
      ;;
    darwin*)
      TS=$(date -v+1S +"%Y%m%d%H%M.%S")
      ;;
  esac
  touch -m -t "$TS" $OUTPUT_FILE;
}

# If neither pane file exists, it must mean that this is the first time we are running in this
# window. In that case, perform one-time initialization. We can safely assume this is running from
# the SQL client pane
if [ ! -f "$CLIENT_PANE" ] && [ ! -f "$EDITOR_PANE" ]; then
  # Ensure the base directory exists
  mkdir -p $QSH_TMP;

  # Ensure we have an input file, even if one isn't setup
  if [[ -z "$EDITOR_FILE" ]]; then
    EDITOR_FILE=$QSH_TMP/query.${PANE_ID}.sql
  fi;

  # Find the name of the SQL client running qsh (for advanced functionality)
  QSH_SQL_CLIENT=$(echo $(basename $(ps -q $(ps -q $PID -o ppid=) -o comm= | awk '{ print $1 }')));

  # If we are aware of the editor, look for an env file to use for initialization
  QSH_ENV="$QSH_BASE/$QSH_SQL_CLIENT/.qshenv";
  if [[ -f "$QSH_ENV" ]]; then
    source "$QSH_ENV";
  fi;

  # Create the editor pane, and pass all options and other values to it. Also ensure that if the
  # editor is closed, all pane files are cleaned up. This allows for the editor to be re-opened
  # again in the same tmux window without issue, and reduces the proliferation of tmp files
  EDITOR_PANE_ID=$(tmux split-window "export QSH='$QSH' \
                                             QSH_PAGER_COMMAND='$QSH_PAGER_COMMAND' \
                                             QSH_EXECUTE_QUERY='$QSH_EXECUTE_QUERY' \
                                             QSH_PAGER='$QSH_PAGER' \
                                             QSH_EDITOR_COMMAND='$QSH_EDITOR_COMMAND' \
                                             QSH_SWITCH_ON_EXECUTE='$QSH_SWITCH_ON_EXECUTE' \
                                             QSH_EXECUTE_DELAY='$QSH_EXECUTE_DELAY' \
                                             QSH_SQL_CLIENT='$QSH_SQL_CLIENT' \
                                             PANE_ID=$(tmux display-message -p '#{pane_id}');
                                      $QSH_EDITOR $EDITOR_FILE; \
                                      rm -f $QSH_TMP/editor.$PANE_ID; \
                                      rm -f $CLIENT_PANE;" \; \
                   swap-pane -U \; \
                   display-message -p '#{pane_id}');

  # Store the pane for the editor in the client pane file
  echo $EDITOR_PANE_ID > $CLIENT_PANE;

  # Store this (the SQL client) pane ID in the editor pane file
  echo ${PANE_ID} > $QSH_TMP/editor.${EDITOR_PANE_ID};

  # If there is a SQL client specific initialization script, use that, otherwise use the generic
  # version, which should be fine for most database platforms
  QSH_INIT="$QSH_BASE/$QSH_SQL_CLIENT/$QSH_INIT_FILE";
  if [[ ! -f "$QSH_INIT" ]]; then
    QSH_INIT="$QSH_BASE/$QSH_INIT_FILE"
  fi;

  # If we don't have a SQL client directory for the current client, things might work, might not,
  # and we definitely won't have access to any scripts, etc.
  if [[ ! -d "$QSH_BASE/$QSH_SQL_CLIENT" ]]; then
    QSH_SQL_CLIENT="??"
  fi;
 
  # Initialize qsh and put up a nice message to let the user know we're good to go
  "$QSH_INIT" "$PANE_ID" "$QSH_SQL_CLIENT" "$QSH_PAGER_COMMAND" "$QSH_NO_CHANGE_PROMPT" \
    "$QSH_PROMPT" "$OUTPUT_FILE";

  # Ensure the modified datetime of the output file looks legit
  touch_output;

  exit 0;
fi;

# If the $EDITOR_PANE file exists, it must mean the editor is running this script, so perform
# editor-side processing. Normally this is the case when the editor wants to send a query to
# the SQL client
if [[ -f "$EDITOR_PANE" ]]; then
  # Capture details of the SQL client from the editor pane file
  CLIENT_PANE_ID=$(cat $EDITOR_PANE);
  CLIENT_PID=$(tmux list-panes -F '#{pane_id}.#{pane_pid}' | grep "^${CLIENT_PANE_ID}[.]" \
               | cut -d . -f 2);

  # There may be results currently being displayed in the SQL client with a pager, so in that case
  # we'll need to exit out of the pager before sending over the new query
  if [[ ! -z "$(pstree $CLIENT_PID | grep $(basename $QSH_PAGER_COMMAND))" ]]; then
    tmux send-keys -t $CLIENT_PANE_ID "C-m";
    tmux send-keys -t $CLIENT_PANE_ID "q";

    # If there are a lot of results, sometimes it can take a little while for the pager to exit,
    # so loop until we can be sure it has stopped
    while [[ ! -z "$(pstree $CLIENT_PID | grep $(basename $QSH_PAGER_COMMAND))" ]]; do
      sleep 0.5;
    done;
  fi;

  # Files used for result requests, i.e. where we will return results back to the editor, rather
  # than actually displaying them on the screen. This is used for enhanced query editing.
  RESULT_REQUEST="$QSH_TMP/client.${CLIENT_PANE_ID}.result-request";
  RESULT_REQUEST_OUTPUT="${RESULT_REQUEST}.data";
  RESULT_REQUEST_COMPLETE="${RESULT_REQUEST}.complete";

  # Delete any previous result request file(s)
  rm -f "$RESULT_REQUEST" "$RESULT_REQUEST_OUTPUT" "$RESULT_REQUEST_COMPLETE";

  # The default operation type
  OPERATION_TYPE=sql

  # Check for parameters, which are used to override the default 'sql' action and perform alternative
  # processing, such as executing a script
  if [[ $# -gt 0 ]]; then
    OPERATION_TYPE=$1
  fi;

  case $OPERATION_TYPE in
    sql)
      # Default processing, nothing to do
      ;;

    client-*)
      # Figure out the script to be called and it's parameters
      QUERY_SCRIPT=$(echo "$2" | awk -F " " '{ print $1; }');
      SCRIPT_PARAMETERS=$(echo "$2" | awk -F " " '{ $1=""; print $0; }');

      # Locate the client query script to call
      CLIENT_QUERY_SCRIPT=$QSH_BASE/$QSH_SQL_CLIENT/$QUERY_SCRIPT;

      # Allow the client script to process the query to be executed
      "$CLIENT_QUERY_SCRIPT" "$QSH_EXECUTE_QUERY" "$SCRIPT_PARAMETERS";
      ;;
  esac

  # If a result request is being processed, create the file that will signal the QSH pager that
  # this is what we want. When it sees this file, it will output the results to a file, rather
  # than outputting them on the screen
  if [[ "$OPERATION_TYPE" == "client-result" ]]; then
    touch "$RESULT_REQUEST";
  fi;

  # Switch over to the SQL client pane when executing a query, to ensure it becomes visible
  tmux select-pane -t $CLIENT_PANE_ID;

  # Finally, trigger the editor in the SQL client, which will cause it to re-enter this script. We
  # need that to happen so that it can pick up the query file and execute it
  tmux send-keys -t $CLIENT_PANE_ID "$QSH_EDITOR_COMMAND";
  tmux send-keys -t $CLIENT_PANE_ID "C-m";

  # If configured to NOT switch to the client on query execute, switch back to the editor, after
  # a small artifical delay to ensure the SQL client pane starts executing the $QSH_EDITOR_COMMAND
  if [[ "$QSH_SWITCH_ON_EXECUTE" != "1" ]]; then
    sleep $QSH_EXECUTE_DELAY && tmux select-pane -l;
  fi;

  # For result requests, we will have to wait until the operation is complete
  if [[ "$OPERATION_TYPE" == "client-result" ]]; then
    # Wait for the signal from the pager that we are done
    while [[ ! -f "$RESULT_REQUEST_COMPLETE" ]]; do
      sleep 0.5;
    done;

    # Print the output so that it can be picked up by the editor
    cat "$RESULT_REQUEST_OUTPUT";
  fi;

  exit 0;
fi;

# If we are still here, this is being executed by the SQL client, and only in the case where there
# is a query file to be processed, which should be stored in $QSH_EXECUTE_QUERY. All we need to do is
# copy the contents of the SQL file to the location requested by the SQL client, i.e. $OUTPUT_FILE,
# which will then pick it up and execute it. A copy is used instead of move to not invalidate open
# file handles
cat $QSH_EXECUTE_QUERY > $OUTPUT_FILE;

# Ensure the modified datetime of the output file looks legit
touch_output;

